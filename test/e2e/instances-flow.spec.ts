import { test, expect } from '@playwright/test'

/**
 * üî• TESTE E2E - Fluxo Completo de Inst√¢ncias WhatsApp
 *
 * Valida:
 * - Login de diferentes tipos de usu√°rios
 * - Acesso √† p√°gina de integra√ß√µes
 * - Listagem de inst√¢ncias
 * - Permiss√µes baseadas em organizationRole
 * - Interface UX (StatusBadge, EmptyState)
 */

const USERS = {
  admin: { email: 'admin@quayer.com', password: 'admin123456', role: 'admin', orgRole: null },
  master: { email: 'master@acme.com', password: 'master123456', role: 'user', orgRole: 'master' },
  manager: { email: 'manager@acme.com', password: 'manager123456', role: 'user', orgRole: 'manager' },
  user1: { email: 'user1@acme.com', password: 'user123456', role: 'user', orgRole: 'user' },
  user2: { email: 'user2@acme.com', password: 'user123456', role: 'user', orgRole: 'user' },
  user3: { email: 'user3@acme.com', password: 'user123456', role: 'user', orgRole: 'user' },
}

test.describe('üöÄ Fluxo de Inst√¢ncias WhatsApp', () => {

  test.beforeEach(async ({ page }) => {
    // Configurar listener de erros
    page.on('console', msg => {
      if (msg.type() === 'error') {
        console.log('‚ùå Console error:', msg.text())
      }
    })
    page.on('pageerror', error => {
      console.log('‚ùå Page error:', error.message)
    })
  })

  test('1. üîê Master: Login e acesso √† p√°gina de integra√ß√µes', async ({ page }) => {
    await page.goto('http://localhost:3005/login')

    // Aguardar carregamento completo
    await page.waitForSelector('input[type="email"]', { state: 'visible' })

    // Fazer login
    await page.fill('input[type="email"]', USERS.master.email)
    await page.fill('input[type="password"]', USERS.master.password)
    await page.click('button[type="submit"]')

    // Aguardar redirecionamento
    await page.waitForURL('**/integracoes/**', { timeout: 10000 })

    const url = page.url()
    console.log('‚úÖ Redirecionado para:', url)

    expect(url).toContain('/integracoes')
  })

  test('2. üìã Master: Validar listagem de inst√¢ncias', async ({ page }) => {
    // Login
    await page.goto('http://localhost:3005/login')
    await page.fill('input[type="email"]', USERS.master.email)
    await page.fill('input[type="password"]', USERS.master.password)
    await page.click('button[type="submit"]')
    await page.waitForURL('**/integracoes/**', { timeout: 10000 })

    // Aguardar carregamento da p√°gina
    await page.waitForLoadState('networkidle')
    await page.waitForTimeout(1000)

    // Verificar se a p√°gina de integra√ß√µes carregou
    const hasTitle = await page.locator('h1, h2').first().isVisible()
    console.log('‚úÖ T√≠tulo da p√°gina vis√≠vel:', hasTitle)

    // Verificar se h√° tabela ou lista de inst√¢ncias
    const hasTable = await page.locator('table, [role="table"]').count() > 0
    const hasList = await page.locator('[role="list"]').count() > 0
    const hasCards = await page.locator('[data-instance], .instance-card').count() > 0

    console.log(`üìä Elementos encontrados:`)
    console.log(`  - Tabela: ${hasTable}`)
    console.log(`  - Lista: ${hasList}`)
    console.log(`  - Cards: ${hasCards}`)

    // Deve ter algum tipo de visualiza√ß√£o
    expect(hasTitle).toBe(true)
  })

  test('3. ‚ú® Validar componentes UX (StatusBadge, EmptyState)', async ({ page }) => {
    // Login como master
    await page.goto('http://localhost:3005/login')
    await page.fill('input[type="email"]', USERS.master.email)
    await page.fill('input[type="password"]', USERS.master.password)
    await page.click('button[type="submit"]')
    await page.waitForURL('**/integracoes/**', { timeout: 10000 })
    await page.waitForLoadState('networkidle')

    // Verificar se componentes de status est√£o presentes
    const statusBadges = await page.locator('[data-status], .status-badge, .badge').count()
    console.log(`‚úÖ Status badges encontrados: ${statusBadges}`)

    // Verificar se h√° estado vazio (caso n√£o tenha inst√¢ncias)
    const emptyState = await page.locator('[data-empty], .empty-state, text=/nenhuma inst√¢ncia/i').count()
    console.log(`‚úÖ Empty state encontrado: ${emptyState > 0}`)

    // Pelo menos um dos elementos deve estar presente
    expect(statusBadges >= 0).toBe(true)
  })

  test('4. üîí Validar permiss√µes: Master pode criar inst√¢ncias', async ({ page }) => {
    // Login como master
    await page.goto('http://localhost:3005/login')
    await page.fill('input[type="email"]', USERS.master.email)
    await page.fill('input[type="password"]', USERS.master.password)
    await page.click('button[type="submit"]')
    await page.waitForURL('**/integracoes/**', { timeout: 10000 })
    await page.waitForLoadState('networkidle')

    // Procurar bot√£o de criar nova inst√¢ncia
    const createButtons = await page.locator('button:has-text("Nova"), button:has-text("Criar"), button:has-text("Adicionar"), a:has-text("Nova")').count()
    console.log(`‚úÖ Bot√µes de cria√ß√£o encontrados: ${createButtons}`)

    // Master deve ter permiss√£o para criar
    expect(createButtons).toBeGreaterThan(0)
  })

  test('5. üîí Validar permiss√µes: User comum N√ÉO pode criar inst√¢ncias', async ({ page }) => {
    // Login como user1 (role comum)
    await page.goto('http://localhost:3005/login')
    await page.fill('input[type="email"]', USERS.user1.email)
    await page.fill('input[type="password"]', USERS.user1.password)
    await page.click('button[type="submit"]')
    await page.waitForURL('**/integracoes/**', { timeout: 10000 })
    await page.waitForLoadState('networkidle')

    // Procurar bot√£o de criar nova inst√¢ncia
    const createButtons = await page.locator('button:has-text("Nova"), button:has-text("Criar"), button:has-text("Adicionar")').count()
    console.log(`‚úÖ Bot√µes de cria√ß√£o encontrados para user: ${createButtons}`)

    // User comum N√ÉO deve ter bot√£o de criar (ou deve estar desabilitado)
    // Se o bot√£o existir, verificar se est√° disabled
    if (createButtons > 0) {
      const isDisabled = await page.locator('button:has-text("Nova"), button:has-text("Criar")').first().isDisabled()
      console.log(`‚úÖ Bot√£o desabilitado: ${isDisabled}`)
      expect(isDisabled).toBe(true)
    } else {
      // Bot√£o n√£o existe - correto!
      expect(createButtons).toBe(0)
    }
  })

  test('6. üîÑ Validar API calls corretos', async ({ page }) => {
    const apiCalls: Array<{ method: string, url: string, status: number }> = []

    // Interceptar chamadas de API
    page.on('response', async (response) => {
      const url = response.url()
      if (url.includes('/api/v1/')) {
        apiCalls.push({
          method: response.request().method(),
          url: url.replace('http://localhost:3005', ''),
          status: response.status()
        })
      }
    })

    // Login como master
    await page.goto('http://localhost:3005/login')
    await page.fill('input[type="email"]', USERS.master.email)
    await page.fill('input[type="password"]', USERS.master.password)
    await page.click('button[type="submit"]')
    await page.waitForURL('**/integracoes/**', { timeout: 10000 })
    await page.waitForLoadState('networkidle')

    // Aguardar carregamento de dados
    await page.waitForTimeout(2000)

    console.log('\nüì° Chamadas de API realizadas:')
    apiCalls.forEach(call => {
      console.log(`  ${call.method} ${call.url} ‚Üí ${call.status}`)
    })

    // Deve ter feito login
    const hasLoginCall = apiCalls.some(call => call.url.includes('/auth/login'))
    expect(hasLoginCall).toBe(true)

    // Deve ter listado inst√¢ncias
    const hasInstancesCall = apiCalls.some(call => call.url.includes('/instances'))
    expect(hasInstancesCall).toBe(true)

    // Nenhuma chamada deve ter falhado (500)
    const has500Error = apiCalls.some(call => call.status === 500)
    expect(has500Error).toBe(false)
  })

  test('7. üéØ Admin: Verificar acesso administrativo', async ({ page }) => {
    // Login como admin
    await page.goto('http://localhost:3005/login')
    await page.fill('input[type="email"]', USERS.admin.email)
    await page.fill('input[type="password"]', USERS.admin.password)
    await page.click('button[type="submit"]')

    // Aguardar redirecionamento
    await page.waitForTimeout(2000)

    const url = page.url()
    console.log('‚úÖ Admin redirecionado para:', url)

    // Admin pode ir para /admin ou /integracoes dependendo da l√≥gica
    const isAdminArea = url.includes('/admin') || url.includes('/integracoes')
    expect(isAdminArea).toBe(true)
  })

  test('8. üì± Responsive: P√°gina funciona em mobile', async ({ page }) => {
    // Configurar viewport mobile
    await page.setViewportSize({ width: 375, height: 667 })

    // Login
    await page.goto('http://localhost:3005/login')
    await page.fill('input[type="email"]', USERS.master.email)
    await page.fill('input[type="password"]', USERS.master.password)
    await page.click('button[type="submit"]')
    await page.waitForURL('**/integracoes/**', { timeout: 10000 })
    await page.waitForLoadState('networkidle')

    // Verificar se p√°gina est√° vis√≠vel
    const isVisible = await page.locator('body').isVisible()
    console.log('‚úÖ P√°gina vis√≠vel em mobile:', isVisible)

    expect(isVisible).toBe(true)

    // Restaurar viewport
    await page.setViewportSize({ width: 1280, height: 720 })
  })

  test('9. ‚ö° Performance: Carregamento r√°pido', async ({ page }) => {
    const start = Date.now()

    // Login e navega√ß√£o completa
    await page.goto('http://localhost:3005/login')
    await page.fill('input[type="email"]', USERS.master.email)
    await page.fill('input[type="password"]', USERS.master.password)
    await page.click('button[type="submit"]')
    await page.waitForURL('**/integracoes/**', { timeout: 10000 })
    await page.waitForLoadState('networkidle')

    const loadTime = Date.now() - start
    console.log(`‚ö° Tempo total de carregamento: ${loadTime}ms`)

    // Deve carregar em menos de 10 segundos
    expect(loadTime).toBeLessThan(10000)
  })

  test('10. üîç Todos os 6 usu√°rios conseguem fazer login', async ({ page }) => {
    const results: Array<{ email: string, success: boolean, url: string }> = []

    for (const [name, user] of Object.entries(USERS)) {
      console.log(`\nüß™ Testando ${name} (${user.email})...`)

      await page.goto('http://localhost:3005/login')
      await page.fill('input[type="email"]', user.email)
      await page.fill('input[type="password"]', user.password)
      await page.click('button[type="submit"]')

      // Aguardar redirecionamento ou erro
      await page.waitForTimeout(3000)

      const url = page.url()
      const success = !url.includes('/login')

      results.push({ email: user.email, success, url })
      console.log(`  ${success ? '‚úÖ' : '‚ùå'} ${user.email} ‚Üí ${url}`)
    }

    console.log('\nüìä Resumo final:')
    results.forEach(r => {
      console.log(`  ${r.success ? '‚úÖ' : '‚ùå'} ${r.email}`)
    })

    // Todos devem conseguir fazer login
    const allSuccess = results.every(r => r.success)
    expect(allSuccess).toBe(true)
  })
})
